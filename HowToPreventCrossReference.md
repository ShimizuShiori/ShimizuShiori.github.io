
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->


# 如何防止交叉引用

## 前言

在大部分规划的不是非常合适的项目经常能看到这样一种现象
* 考虑到业务的独立性，创建一个新的 **库/包** 来实现某个业务
* 因为该业务需要引用到一些其它业务，所以加入到 **引入/依赖项** 中去（比如扩展了游戏业务模块，他依赖于用户模块，从用户模块中加载用户的部分信息）

其实这种开发模式本身没有什么问题，无论我参加哪个项目，几乎清一色使用这种模式进行开发的

**但是** ，在某个项目中，同事抛出了一个问题

> 我现在有两个动态库，A已经引用了B，现在因为业务原因，B还需要引用A，怎么办？

很多人一定会说，这肯定是**库**的分隔不合理造成的。

于是，这里就有一了个矛盾，在现在这种迭代式的开发模式中，业务库划分的初期，已知信息其实并不多，那么根据这些不健全的信息进行业务库的划分，后期出错的情况一定是存在的。

为了解决这个问题，应该存在两个方向的方案
* 当出现交叉引用时，如何解决（未端，矛盾已暴露）
* 如何防止出现交叉引用（始端，矛盾未出现）

实事上，当交叉引用的需求已经发生时，我觉得已经很难通过简单的手法进行解决了。因此本人放弃了对未端的分析和解决。

于是，我构思了一种称作为零引用模块的概念，以解决交叉引用的发生

> ps. 本人长年从事C#方面的工作，因此该方案也是基于.Net领域起草的，对于在其它编程领域是否有效，不敢断言。

> ps2. 本文 **仅** 针对没有使用 **消息队列 / 事件总线** 的项目书写的优化建议

## 什么是零引用模块

零引用模块就是指，除去.net平台固有动态**库/框架**以外，没有引用其它任何第三方功能库、业务库的模块（第三方框架除外）。

通过剔除对其它任何业务的依赖，才能真正达预防交叉引用（谁也不引用我，我也不引用谁）。

使用零引用模块，我们就一定要解决下面两个问题
1. 如何调用其它库（引用）
2. 如何被其它库调用（被引用）

## 如何调用其它库

> 通过接口定义需求边界

如何理解呢？打个比方吧

1. 小姑娘想要找个男朋友，可是这男朋友在人海之中，上哪儿找去呢？
2. 于是小姑娘自己做了一张表，表里面有各种各校的内容，比如身高、年龄、爱好、体重等等
3. 表格制作完成了，小姑娘把表交给了某一个交友平台
4. 交友平台在平台上匹配各种男孩的信息，当发现一个完全符合要求的，就提交给这个女孩

咱们把上面的过程映射到Code世界来，大致应该是这样

1. 游戏模块想要通过Session中的ID找到用户的头像、性别和年龄，可是Project中有那么多的Libs，上哪儿找去呢？
2. 于是程序员做了一个接口，定义了几个方法，比如GetGenderByUserId(userId)，GetBirthdayByUserId(userId)等等
3. 接口定义好了以后，把接口告诉程序的入口端
4. 程序入口会搜索类型，一旦发现实现了这个接口的类型，就移交给游戏模块
5. 和上面相比要多做的一件事情，就是为这个接口做一个实现类（也就是在交友平台中创建一个“男朋友”，因为主模块中具备所有模块，因此在这里使用用户模块实现一个游戏模块的接口是合理的）

我们可以对上面的内容进行进一步的规范和优化，这个规范和优化就是仁者见仁的事了，每个人设计出来的肯定是不同的。

在这里，我也提供的一个简要的思路

1. 对依赖的业务创建接口（一个或复数个都可以）
2. 创建静态类Settings，用于记录所有创建接口实现类的
    * Setup方法，供外部（主模块）定义接口实现类的创建方式
    * GetCurrentSetting方法，供内部使用，获取外部定义的各接口实现类的创建方式
3. 所有需要使用到 **1** 的接口实例的地方，均通过 **2** 中的GetCurrentSetting方法获取
4. 在主模块实现 **1** 中的所有接口
5. 在主模块入口中，将 **4** 开发的实现类通过Setup方法通知模块

## 如何被其它库调用

其它库在调用目标库，基本上分为以下两种：
* 主动式调用：根据某某ID获取某某的哪些属性
* 被动式调用：当某某数据被创建时，需要做额外的事情

咱们一个一个说

### 主动式调用

聪明的同学一定发生了，上面的 **如何调用其它库** 就是一个主动式的调用，因此，对于主动式调用，我们在开发当前模块时，完全不用关心。

因为这是调用方需要去实现的工作

### 被动式调用

其实，通过对多个项目的观察，这个是比较容易造成交叉引用的领域。

说一个真实的例子：

我参与的时候，项目中，已经具备组织架构模块了，现在想开发一个文档管理模块，于是另起了一个库。

因为文档模块需要部门、人员的信息很正常的，所以文档模块强引用了组织构架模块。

没过多久，因为一些不便透露的原因，产生了一个新的业务逻辑，就是每创建一个员工，需要初始化一套针对该员工的文档库（基于不便透露的原因，该功能不能以被动的形式实现）

这时候程序员们发生，组织构架模块不能引用文档管理模块，因为文档管理模块就是依赖于组织构架模块的，这个引用关系闭环了

为解燃眉之急，程序员们只能将文档管理中的相关代码复制到组织构架模块中，并在Employee的Created后，调用这些代码进行相应业务的实现。

一旦开始复制代码了，痛苦的路就开始了………………（大家都懂的，就不再多说了）

---

为了解决这个问题，我们可以借用之前的静态类Settings

该类其实是主模块和子模块的沟通类，并且，主模块中可以访问到所有子模块。

根据这些特性，我们可以把一些Event挂载到静态类Settings上面，并在入口类以Settings初始化时，定义这些事件的处理者

比如：

```csharp

///code in entry
EmployeeModule.Settings.Events.EmployeeCreated += (sender, e) => {
    IDocumentManagerService service = someCreateFunc();
    service.InitUserDocuments(e.UserId);
}

///code in Employee
Serivce.Create(userModel);
Module.GetCurrentSetting().OnEmployeeCreated(this, new EmployeeCreatedArgs(userModel));
```

通过Settings静态类，作为事件的宿主，并在主模块中装配处理器，便可完全避免交叉引用的产生。

## 最后

实事上，这种交叉引用的情况还是比较少出现的。
但是解耦的思想应当在贯穿在每一步重要的开发阶段，比如抽象库、创建新业务库、对旧业务的引用、对旧业务的扩展等等。

本文只是以防止交叉引用为例，希望大家能够以此为借，在思想上有更高的升华。